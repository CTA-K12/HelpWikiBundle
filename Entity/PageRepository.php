<?php
/**
 * PageRepository.php file
 *
 * File that contains the help wiki page entity repository class
 *
 * Licence MIT
 * Copyright (c) 2014 Multnomah Education Service District <http://www.mesd.k12.or.us>
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 * 
 * @filesource /src/Mesd/HelpWikiBundle/Entity/PageRepository.php
 * @package    Mesd\HelpWikiBundle\Entity
 * @copyright  2014 (c) Multnomah Education Service District <http://www.mesd.k12.or.us>
 * @license    <http://opensource.org/licenses/MIT> MIT
 * @author     Curtis G Hanson <chanson@mesd.k12.or.us>
 * @version    {@inheritdoc}
 */
namespace Mesd\HelpWikiBundle\Entity;

use Doctrine\Common\Collections;
use Doctrine\Common\Collections\Collection;

use Doctrine\ORM\EntityRepository;

/**
 * PageRepository
 *
 * This class was generated by the Doctrine ORM. Add your own custom
 * repository methods below.
 */
class PageRepository extends EntityRepository
{

    public function getPagesNotEqualToPage($pageId)
    {
        // get all the pages not equal to the page passed
        // used to create a select box for creating page associations
        return $this->createQueryBuilder('p')
            ->where('p.id <> ?1')
            ->orderBy('p.title')
            ->setParameter(1, $pageId)
        ;
    }

    public function getAllPagesByPrintOrder($levels = 0, $security = false)
    {
        // get all the pages not equal to the page passed
        // used to create a select box for creating page associations
        $result = $this
            ->createQueryBuilder('p')
            ->where('p.parent is NULL')
            ->getQuery()
            ->getResult()
        ;

        // define our results as an Array Collection
        // then sort the parent pages
        $entities = new Collections\ArrayCollection($result);
        $pages    = $this->sortCollectionByPrintOrder($entities);

        // recursively sort all the nested child pages
        $this->sortSubCollections($pages);

        return $pages;
    }

    public function getParentPage($pageId)
    {
        // this has to happen with the query

        //    select p.*
        //      from helpwiki_page q
        //inner join helpwiki_page p
        //        on q.parent_id = p.id
        //     where q.id = 4
        $qb = $this->createQueryBuilder('p');
        $qb
            ->innerJoin('\Mesd\HelpWikiBundle\Entity\Page', 'q', 'WITH', 'q.parent = p.id')
            ->where($qb->expr()->eq('q.id', ':childId'))
            ->setParameter('childId', $pageId)
        ;

        $q = $qb->getQuery();

        return $q->getResult();
    }

    public function getPreviousPage(Page $page)
    {
        // the the previous page, like a book

        // if there isn't a previous page
        // get the last page of the previous chapter
        $printOrder = $page->getPrintOrder() - 1;
        $parent     = $page->getParent();
        
        $qb = $this->createQueryBuilder('p');
        $qb->where($qb->expr()->eq('p.printOrder', ':printOrder'));

        if(empty($parent)) {
            $qb->andWhere($qb->expr()->isNull('p.parent'));
        } else {
            $qb->andWhere(
                $qb
                    ->expr()->eq('p.parent', ':parentId'))
                    ->setParameter('parentId', $parent->getId());
        }

        $qb->setParameter('printOrder', $printOrder);

        $q = $qb->getQuery();

        $result = $q->getOneOrNullResult();

        //var_dump($result->getSlug());exit;
        if(empty($result) && !empty($parent)) {
            return $parent;
        }

        if (!empty($result)) {
            $children = $result->getChildren();
            if (0 < $children->count()) {
                return $this->getLastPageInCollection($children);
            }
        }

        return $result;
    }

    public function getNextPage(Page $page, $ignoreChildren = false)
    {
        // get the current printOrder and increment it by 1
        $printOrder = $page->getPrintOrder() + 1;

        // get the parent page
        $parent = $page->getParent();

        // get the child pages
        $children = $page->getChildren();

        // we first start with children
        if (false === $ignoreChildren) {
            if(0 < $children->count()) {
                return $this->getFirstPageInCollection($children);
            }
        }

        $qb = $this->createQueryBuilder('p');
        $qb->where($qb->expr()->eq('p.printOrder', ':printOrder'));
        
        // we match the next page based on common parents
        // and a defined incremental order
        // if a parent exists, use that parameter, otherwise the parent is null
        if (empty($parent)) {
            $qb->andWhere($qb->expr()->isNull('p.parent'));
        } else {
            $qb->andWhere(
                $qb
                    ->expr()->eq('p.parent', ':parentId'))
                    ->setParameter('parentId', $parent->getId());
        }
        
        $qb->setParameter('printOrder', $printOrder);

        $q = $qb->getQuery();

        $result = $q->getOneOrNullResult();

        // if there isn't another page,
        // lets get the next parent page
        if(empty($result) && !empty($parent)) {
            return $this->getNextPage($parent, true);
        }

        // if there isn't even that,
        // then we're on the last page,
        // we should return false
        return $q->getOneOrNullResult();
    }

    public function getFirstPageInCollection(Collection $pages)
    {
        // this function finds the first page in a collection of pages
        $iterator = $pages->getIterator();

        $iterator->uasort(function ($a, $b) {
            return ($a->getPrintOrder() < $b->getPrintOrder()) ? -1 : 1;
        });

        $collection = new Collections\ArrayCollection(iterator_to_array($iterator));

        return $collection->first();
    }

    public function getLastPageInCollection(Collection $pages)
    {
        // this function finds the first page in a collection of pages
        $iterator = $pages->getIterator();

        $iterator->uasort(function ($a, $b) {
            return ($a->getPrintOrder() < $b->getPrintOrder()) ? -1 : 1;
        });

        $collection = new Collections\ArrayCollection(iterator_to_array($iterator));

        return $collection->last();
    }

    private function sortSubCollections($entities)
    {
        foreach ($entities as $entity) {
            if (!$entity->getChildren()->isEmpty()) {
                $children = $this->sortCollectionByPrintOrder($entity->getChildren());
                $this->sortSubCollections($children);

                $entity->setChildren($children);
            }
        }
    }

    private function sortCollectionByPrintOrder(Collection $collection)
    {
        $iterator = $collection->getIterator();

        $iterator->uasort(function ($a, $b) {
            return ($a->getPrintOrder() < $b->getPrintOrder()) ? -1 : 1;
        });

        $collection = new Collections\ArrayCollection(iterator_to_array($iterator));

        return $collection;
    }
}
