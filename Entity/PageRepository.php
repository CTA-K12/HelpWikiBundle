<?php
/**
 * PageRepository.php file
 *
 * File that contains the help wiki page entity repository class
 *
 * Licence MIT
 * Copyright (c) 2014 Multnomah Education Service District <http://www.mesd.k12.or.us>
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 * 
 * @filesource /src/Mesd/HelpWikiBundle/Entity/PageRepository.php
 * @package    Mesd\HelpWikiBundle\Entity
 * @copyright  2014 (c) Multnomah Education Service District <http://www.mesd.k12.or.us>
 * @license    <http://opensource.org/licenses/MIT> MIT
 * @author     Curtis G Hanson <chanson@mesd.k12.or.us>
 * @version    {@inheritdoc}
 */
namespace Mesd\HelpWikiBundle\Entity;

use Doctrine\Common\Collections;
use Doctrine\Common\Collections\Collection;

use Doctrine\ORM\EntityRepository;

//use Gedmo\Tree\Entity\Repository\NestedTreeRepository;
//use Gedmo\Sortable\Entity\Repository\SortableRepository;

/**
 * PageRepository
 *
 * This class was generated by the Doctrine ORM. Add your own custom
 * repository methods below.
 */
class PageRepository extends EntityRepository
{
    public function getPagesNotEqualToPage($pageId)
    {
        // get all the pages not equal to the page passed
        // used to create a select box for creating page associations
        return $this->createQueryBuilder('p')
            ->where('p.id <> ?1')
            ->orderBy('p.title')
            ->setParameter(1, $pageId)
        ;
    }

    public function findAllByTree($options = array())
    {
        // $flatten    - default false
        //               returns array with no children, only parent_id
        // $levels     - limits recursion,
        //               only matters for flattened data
        // $standAlone - default false
        // $status     - default in('PUBLISHED')
        // orderBy     - default array(printOrder, ASC)
        // $security   - not implemented yet
        $flatten = array_key_exists('flatten', $options) ? $options['flatten'] : false;

        $qb = $this
            ->createQueryBuilder('p')
            ->where('p.status IN (:status)')
            ->andWhere('p.standAlone = false')
            ->orderBy('p.position', 'ASC')
            ->setParameter('status', array('PUBLISHED'))
        ;

        if (false == $flatten)
        {
            $qb->andWhere('p.parent IS NULL');
        }

        $result = $qb->getQuery()->getResult();

        // define our results as an Array Collection
        // then sort the parent pages
        $collection = new Collections\ArrayCollection($result);

        $pages      = $this->sortCollectionByPosition($collection);
        
        // recursively sort all the nested child pages
        $this->sortSubCollections($pages);

        return $pages;
    }

    public function getParentPage($pageId)
    {
        // this has to happen with the query

        //    select p.*
        //      from helpwiki_page q
        //inner join helpwiki_page p
        //        on q.parent_id = p.id
        //     where q.id = 4
        $qb = $this->createQueryBuilder('p');
        $qb
            ->innerJoin('\Mesd\HelpWikiBundle\Entity\Page', 'q', 'WITH', 'q.parent = p.id')
            ->where($qb->expr()->eq('q.id', ':childId'))
            ->setParameter('childId', $pageId)
        ;

        $q = $qb->getQuery();

        return $q->getResult();
    }

    public function getPreviousPage(Page $page)
    {
        // the the previous page, like a book

        // if there isn't a previous page
        // get the last page of the previous chapter
        $position = $page->getPosition() - 1;
        $parent   = $page->getParent();
        
        $qb = $this->createQueryBuilder('p');
        $qb->where($qb->expr()->eq('p.position', ':position'));

        if(empty($parent))
        {
            $qb->andWhere($qb->expr()->isNull('p.parent'));
        }
        else
        {
            $qb->andWhere(
                $qb
                    ->expr()->eq('p.parent', ':parentId'))
                    ->setParameter('parentId', $parent->getId());
        }

        $qb->setParameter('position', $position);

        $q = $qb->getQuery();

        $result = $q->getOneOrNullResult();

        //var_dump($result->getSlug());exit;
        if(empty($result) && !empty($parent))
        {
            return $parent;
        }

        if (!empty($result))
        {
            $children = $result->getChildren();
            if (0 < $children->count())
            {
                return $this->getLastPageInCollection($children);
            }
        }

        return $result;
    }

    public function getNextPage(Page $page, $ignoreChildren = false)
    {
        if (false === $ignoreChildren)
        {
            // if not, we should see if the page has children
            $children = $page->getChildren();

            // if the page has children, return the first child
            if(0 < $children->count())
            {
                return $this->getFirstPageInCollection($children);
            }
        }
        
        // we first determine if the page has a sibling
        if ($rightPage = $page->getRight())
        {
            // if so, lets return it
            return $rightPage;
        }

        // if not, determine if the page has a parent
        if ($parentPage = $page->getParent())
        {

            // if so, determine if parent's right page exists
            if ($parentRightPage = $parentPage->getRight())
            {
                // if so, return it
                return $parentRightPage;
            }
        }
        
        // out of curiosity, is there another tick on the position?
        $nextPosition = $page->getPosition() + 1;

        $qb = $this
            ->createQueryBuilder('p')
            ->where('p.position = :position')
            ->setParameter('position', $nextPosition)
        ;

        $result = $qb->getQuery()->getResult();
        
        // define our results as an Array Collection
        // then sort the parent pages
        $collection = new Collections\ArrayCollection($result);

        // if there's only one page
        if(1 === $collection->count())
        {
            return $collection->first();
        }

        // if there isn't even that
        // then we're on the last page,
        // we should return false
        return false;
    }

    public function getFirstPageInCollection(Collection $pages)
    {
        // this function finds the first page in a collection of pages
        $iterator = $pages->getIterator();

        $iterator->uasort(function ($a, $b) {
            return ($a->getPosition() < $b->getPosition()) ? -1 : 1;
        });

        $collection = new Collections\ArrayCollection(iterator_to_array($iterator));

        return $collection->first();
    }

    public function getLastPageInCollection(Collection $pages)
    {
        // this function finds the first page in a collection of pages
        $iterator = $pages->getIterator();

        $iterator->uasort(function ($a, $b) {
            return ($a->getPrintOrder() < $b->getPrintOrder()) ? -1 : 1;
        });

        $collection = new Collections\ArrayCollection(iterator_to_array($iterator));

        return $collection->last();
    }

    private function sortSubCollections($entities)
    {
        foreach ($entities as $entity)
        {
            if (!$entity->getChildren()->isEmpty())
            {
                $children = $this->sortCollectionByPosition($entity->getChildren());
                $this->sortSubCollections($children);

                $entity->setChildren($children);
            }
        }
    }

    private function sortCollectionByPosition(Collection $collection)
    {
        $iterator = $collection->getIterator();

        $iterator->uasort(function ($a, $b) {
            return ($a->getPosition() < $b->getPosition()) ? -1 : 1;
        });

        $collection = new Collections\ArrayCollection(iterator_to_array($iterator));

        return $collection;
    }
}
